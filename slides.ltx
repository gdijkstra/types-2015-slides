\documentclass{beamer}

\usetheme{Madrid}
\usecolortheme{dolphin}
\setbeamertemplate{navigation symbols}{} 

%include slides.fmt

\usepackage{color}

%% Encoding, font stuff
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10,protrusion=trues]{microtype}
\usepackage{tgpagella}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,stmaryrd}

\usepackage{alltt}

%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}

%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\verb+--without-K+\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}

% Path composition from The Book.
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}


\title[Towards a theory of HITs]{Towards a theory of \hits}

\author[]{
  Thorsten Altenkirch\inst{1}
\and
  Paolo Capriotti\inst{1}
\and
  \emph{Gabe Dijkstra}\inst{1}\\
\and
  Fredrik Nordvall Forsberg\inst{2}
}

\institute[]{
  \inst{1} University of Nottingham
\and
  \inst{2} University of Strathclyde
 }

\date{\today}

\begin{document}


\begin{frame}
\maketitle
\end{frame}

\begin{frame}{Goal}
  |hdots|
\end{frame}

\begin{frame}{\Hits versus \oits}
Ordinary inductive types:
\begin{code}
  data T : Type where
    c0  : F0 T -> T
        vdots
    ck  : Fk T -> T
\end{code}

where every |Fi : Type -> Type| is a (strictly positive) functor.
\end{frame}

\begin{frame}{\Hits versus \oits}
Ordinary inductive types:
\begin{code}
  data T : Type where
    c  : F0 T + hdots + Fk T -> T
\end{code}

where every |Fi : Type -> Type| is a (strictly positive) functor.
\end{frame}

\begin{frame}{\Hits versus \oits}
Ordinary inductive types:
\begin{code}
  data T : Type where
    c  : F T -> T
\end{code}

where |F : Type -> Type| is a (strictly positive) functor.
\end{frame}

\begin{frame}{\Hits versus \oits}
  Higher inductive types:

  \begin{code}
    data T2 : Type where
      base : T2
      p : base = base
      q : base = base
      t : p trans q = q trans p
  \end{code}

  \begin{itemize}
  \item Dependencies on previous constructors
  \item \emph{Higher} constructors: target of constructors not always
    |T|, but can also be an iterated path space of |T|.
  \end{itemize}

  Single functor |Type -> Type| no longer suffices
\end{frame}

\begin{frame}{General framework}
  In general: constructors are \emph{dependent dialgebras}:

  \begin{code}
    data T : Type
      c0 : (x : F0 T)                     -> G0 T x
         vdots
      ck : (x : Fk (T, c0, hdots, ckmo))  -> Gk (T, c0, hdots, ckmo) x
  \end{code}

  We will call:

  \begin{itemize}
  \item Every |Fi| an \emph{arguments} functor
  \item Every |Gi| a \emph{target} functor
  \end{itemize}
\end{frame}

\begin{frame}{General framework}
  Constructors are \emph{dependent dialgebras}:

  \begin{code}
    c : (x : F X) -> G (X, x)
  \end{code}

  where 

  \begin{itemize}
  \item |catC : Cat| with an adjunction |L dashv U : catC -> Type|
  \item |F : catC -> Type|
  \item |G : int catC F -> Type|
  \end{itemize}

\end{frame}

\begin{frame}{General framework -- \zeroconstructors}
  \zeroconstructors are \emph{dependent dialgebras}:

  \begin{code}
    c : (x : F X) -> G (X, x)
  \end{code}

  where 

  \begin{itemize}
  \item |C : Cat| with an adjunction |L dashv U : catC -> Type|
  \item |F : catC -> Type|
  \item |G : int catC F -> Type|
  \end{itemize}

  \begin{code}
    G (X, x) ddefeq X
  \end{code}


\end{frame}

\begin{frame}{General framework -- \oneconstructors}
  \oneconstructors are \emph{dependent dialgebras}:

  \begin{code}
    c : (x : F X) -> hdots eqUX hdots
  \end{code}

  where 

  \begin{itemize}
  \item |C : Cat| with an adjunction |L dashv U : catC -> Type|
  \item |F : catC -> Type|
  \item |G : int catC F -> Type|
  \end{itemize}

  \begin{code}
    G (X, x) ddefeq (hdots eqUX hdots)
  \end{code}

\end{frame}

\begin{frame}{General framework -- \oneconstructors}
  \oneconstructors are \emph{dependent dialgebras}:

  \begin{code}
    c : (x : F X) -> l X x eqUX r X x
  \end{code}

  where 

  \begin{itemize}
  \item |C : Cat| with an adjunction |L dashv U : catC -> Type|
  \item |F : catC -> Type|
  \item |l r : F -> U|
  \item |Eq0 : int catC F -> Type|
  \end{itemize}

  \begin{code}
    Eq0 (X, x) ddefeq (l X x eqUX r X x)
  \end{code}

\end{frame}

\begin{frame}{General framework -- \twoconstructors}
  For \twoconstructors:

  \begin{code}
    c : (x : F X) -> l1 X x eq0 r1 X x
  \end{code}

  where 

  \begin{itemize}
  \item |C : Cat| with an adjunction |L dashv U : catC -> Type|
  \item |F : catC -> Type|
  \item |l0 r0 : F -> U|
  \item |Eq0 : int catC F -> Type| \\
        |Eq0 (X, x) ddefeq (l X x eqUX r X x)|
  \item |l1 r1 : 1 -> Eq0|
  \end{itemize}

  \begin{code}
    Eq1 : int catC F -> Type
    Eq1 (X, x) ddefeq (l1 X x eq0 r1 X x)
  \end{code}

  \begin{code}

  \end{code}

\end{frame}

\begin{frame}{Strict positivity -- \oits}
  We can't allow any arguments functor: it has to be strictly positive:

  \begin{code}
    data Term : Type where
      lam : (Term -> Term) -> Term 
  \end{code}

\end{frame}

\begin{frame}{Strict positivity -- \hits}
  We can't allow any arguments functor: it has to be strictly positive:

  \begin{code}
    data InitialField : Type where
      0  : InitialField
      1  : InitialField
      ADD  : InitialField -> InitialField -> InitialField
      MUL  : InitialField -> InitialField -> InitialField
      vdots
      inv : (x : InitialField) -> (x = 0 -> bot) -> InitialField
      vdots
  \end{code}

  does not exist: |inv| is not strictly positive
\end{frame}


\begin{frame}{Strict positivity -- |catC|-containers}
  Strictly positive functors |Type -> Type|: containers:

  \begin{itemize}
  \item Shapes |S : Type|
  \item Positions |T : S -> Type|
  \end{itemize}

  |sem(S lhd P) : Type -> Type| \\
  |sem(S lhd P) X ddefeq (s : S) times (P s -> X)|
  
\end{frame}

\begin{frame}{Strict positivity -- |catC|-containers}
  Strictly positive functors |catC -> Type|: |catC|-containers

  \begin{itemize}
  \item Shapes |S : Type|
  \item Positions |T : S -> / catC / |
  \end{itemize}

  |sem(S lhd P) : catC -> Type| \\
  |sem(S lhd P) X ddefeq (s : S) times C(P s, X)|
    
  \begin{itemize}
  \item Container morphisms: natural transformations
  \end{itemize}
\end{frame}

\begin{frame}{Strict positivity -- |catC|-containers}
  It is reasonable to require that the argument functors |Fi| be
  containers.

  Are the |Eqi| functors expressible as containers?
\end{frame}

\begin{frame}{Coherence problems}
  \begin{itemize}
  \item We can use |catC|-containers to internalise the theory
  \item We still need to be able to talk about the categories of dependent dialgebras
  \item $\hdots$ but this comes with coherence problems
  \end{itemize}
\end{frame}

\begin{frame}{Conclusions}
  \begin{itemize}
  \item |catC|-containers get us far
  \item Defining categories of algebras is problematic
  \end{itemize}

\end{frame}

\end{document}
