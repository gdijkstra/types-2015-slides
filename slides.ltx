\documentclass{beamer}

\usetheme{Madrid}
\usecolortheme{dolphin}
\setbeamertemplate{navigation symbols}{} 

%include slides.fmt

\usepackage{color}

%% Encoding, font stuff
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10,protrusion=trues]{microtype}
\usepackage{tgpagella}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,stmaryrd}
\usepackage[normalem]{ulem}
\usepackage{alltt}

%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}

%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\verb+--without-K+\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\threeconstructor}{$3$-constructor\xspace}
\newcommand{\threeconstructors}{$3$-constructors\xspace}
\newcommand{\nconstructor}{$n$-constructor\xspace}
\newcommand{\nconstructors}{$n$-constructors\xspace}

\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}

% Path composition from The Book.
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}


\title[Towards a theory of HITs]{Towards a theory of \hits}

\author[]{
  Thorsten Altenkirch\inst{1}
\and
  Paolo Capriotti\inst{1}
\and
  \emph{Gabe Dijkstra}\inst{1}\\
\and
  Fredrik Nordvall Forsberg\inst{2}
}

\institute[]{
  \inst{1} University of Nottingham
\and
  \inst{2} University of Strathclyde
 }

\date{\today}

\begin{document}


\begin{frame}
\maketitle
\end{frame}

\begin{frame}{Goal}
  |hdots|
\end{frame}

\begin{frame}{\Hits versus \oits}
Ordinary inductive types:
\begin{code}
  data T : Type where
    c0  : F0 T -> T
        vdots
    ck  : Fk T -> T
\end{code}

where every |Fi : Type -> Type| is a (strictly positive) functor.
\end{frame}

\begin{frame}{\Hits versus \oits}
Ordinary inductive types:
\begin{code}
  data T : Type where
    c  : F0 T + hdots + Fk T -> T
    emptydots
    empty
\end{code}

where every |Fi : Type -> Type| is a (strictly positive) functor.
\end{frame}

\begin{frame}{\Hits versus \oits}
Ordinary inductive types:
\begin{code}
  data T : Type where
    c  : F T -> T
    emptydots
    empty
\end{code}

where |F : Type -> Type| is a (strictly positive) functor.
\end{frame}

\begin{frame}{\Hits versus \oits}
  Higher inductive types, \eg the circle:

  \begin{code}
    data S1 : Type where
      base  : S1
      loop  : base = base
  \end{code}

  \begin{itemize}
  \item Dependencies on previous constructors
  \item \emph{Higher} constructors: target of constructors not always
    |T|, but can also be an iterated path space of |T|.
  \end{itemize}

  Single functor |Type -> Type| no longer suffices
\end{frame}

\begin{frame}{General framework}
  Constructors are \emph{dependent dialgebras}:

  \begin{code}
    data T : Type where
      c0  : (x : F0 T)                     -> G0 (T, x)
      c1  : (x : F1 (T, c0))               -> G1 ((T, c0), x)
         vdots
      ck  : (x : Fk (T, c0, hdots, ckmo))  -> Gk ((T, c0, hdots, ckmo), x)
  \end{code}

  We will call:

  \begin{itemize}
  \item Every |Fi| an \emph{arguments} functor
  \item Every |Gi| a \emph{target} functor
  \end{itemize}
\end{frame}

\begin{frame}{General framework -- example: \emph{interval}}
  The interval type: 

  \begin{code}
    data I : Type where
      zero  : I
      one   : I
      seg   : zero = one
  \end{code}

  Argument functors:

  \savecolumns
  \begin{code}
    F0 X                 ddefeq 1        (F0  : Type   -> Type)
    F1 (X, z)            ddefeq 1        (F1  : F0Alg  -> Type)
    F2 (X, z, o)         ddefeq 1        (F2  : F1Alg  -> Type)
  \end{code}

  Target functors:

  \restorecolumns
  \begin{code}
    G0 (X          , x)  ddefeq X        (G0  : IntType  F0 -> Type)
    G1 ((X, z)     , x)  ddefeq X        (G1  : Int0     F1 -> Type)
    G2 ((X, z, o)  , x)  ddefeq (z = o)  (G2  : Int1     F2 -> Type)
  \end{code}

\end{frame}


\begin{frame}{General framework}
  Constructors are \emph{dependent dialgebras}:

  \begin{code}
    c : (x : F X) -> G (X, x)
  \end{code}

  where 

  \begin{itemize}
  \item |catC : Cat| 
  \item |F : catC -> Type| (\emph{arguments} functor)
  \item |G : IntC F -> Type| (\emph{target} functor)
  \end{itemize}

\end{frame}

\begin{frame}{General framework -- \zeroconstructors}
  \zeroconstructors are of the form:

  \begin{code}
    c : (x : F X) -> U X
  \end{code}

  where 

  \begin{itemize}
  \item |C : Cat| with a forgetful functor |U : catC -> Type|
  \item |F : catC -> Type|
  \item |G : IntC F -> Type|
  \end{itemize}

  \begin{code}
    G (X, x) ddefeq U X
  \end{code}


\end{frame}

\begin{frame}{General framework -- \oneconstructors}
  \oneconstructors are of the form:

  \begin{code}
    c : (x : F X) -> (l0 X x = r0 X x)
  \end{code}

  where 

  \begin{itemize}
  \item |C : Cat| with a forgetful functor |U : catC -> Type|
  \item |F : catC -> Type|
  \item |G : IntC F -> Type|
  \item |l0 r0 : F -> U|
  \end{itemize}

  \begin{code}
    G (X, x) ddefeq (l0 X x = r0 X x)
  \end{code}

  We call this functor |Eq0|

\end{frame}

\begin{frame}{General framework -- \twoconstructors}
  For \twoconstructors:

  \begin{code}
    c : (x : F X) -> (l1 X x = r1 X x)
  \end{code}

  where 

  \begin{itemize}
  \item |l0 r0 : F -> U| \hfill (with |Eq0 (X, x) ddefeq (l0 X x = r0 X x)|) \hspace{2em}
  \item |l1 r1 : 1 -> Eq0| \hfill (with |Eq1 (X, x) ddefeq (l1 X x = r1 X x)|) \hspace{2em}
  \end{itemize}

\end{frame}

\begin{frame}{General framework -- \threeconstructors}
  For \threeconstructors:

  \begin{code}
    c : (x : F X) -> (l2 X x = r2 X x)
  \end{code}

  where 

  \begin{itemize}
  \item |l0 r0 : F -> U| \hfill (with |Eq0 (X, x) ddefeq (l0 X x = r0 X x)|) \hspace{2em}
  \item |l1 r1 : 1 -> Eq0| \hfill (with |Eq1 (X, x) ddefeq (l1 X x = r1 X x)|) \hspace{2em}
  \item |l2 r2 : 1 -> Eq1| \hfill (with |Eq2 (X, x) ddefeq (l2 X x = r2 X x)|) \hspace{2em}
  \end{itemize}

\end{frame}

\begin{frame}{General framework -- \nconstructors}
  For \nconstructors:

  \begin{code}
    c : (x : F X) -> (ln' X x = rn' X x)
  \end{code}

  where 

  \begin{itemize}
  \item |l0 r0 : F -> U| \hfill (with |Eq0 (X, x) ddefeq (l0 X x = r0 X x)|) \hspace{2em}
  \item |l1 r1 : 1 -> Eq0| \hfill (with |Eq1 (X, x) ddefeq (l1 X x = r1 X x)|) \hspace{2em}
  \item |l2 r2 : 1 -> Eq1| \hfill (with |Eq2 (X, x) ddefeq (l2 X x = r2 X x)|) \hspace{2em} \\ |vdots|
  \item |ln' rn' : 1 -> Eqn''| \hfill (with |Eqn' (X, x) ddefeq (ln' X x = r'n X x)|) \hspace{2em}    
  \end{itemize}

\end{frame}


\begin{frame}{Strict positivity -- \oits}
  We can't allow any arguments functor: it has to be strictly positive:

  \begin{code}
    data Term : Type where
      lam : (Term -> Term) -> Term 
  \end{code}
  
\end{frame}

\begin{frame}{Strict positivity -- \hits}
  We can't allow any arguments functor: it has to be strictly positive:

  \begin{code}
    data InitialField : Type where
      0  : InitialField
      1  : InitialField
      ADD  : InitialField -> InitialField -> InitialField
      MUL  : InitialField -> InitialField -> InitialField
      vdots
      inv : (x : InitialField) -> (x = 0 -> bot) -> InitialField
      vdots
  \end{code}

  |InitialField| does not exist: |inv| is not strictly positive
\end{frame}


\begin{frame}{|Type|-containers}
  Strictly positive functors |Type -> Type|: containers:

  \begin{itemize}
  \item Shapes |S : Type|
  \item Positions |T : S -> Type|
  \end{itemize}

  \begin{code}
  sem(S lhd P) : catC -> Type
  sem(S lhd P) X ddefeq (s : S) times (P s -> X)


  sem(S lhd P) : (f : X -> Y) -> sem(S lhd P) X -> sem(S lhd P) Y
  sem(S lhd P) f (s , t) ddefeq (s , f circ t)
  \end{code}

  Example:

  \begin{code}
  const A X  = sem(A lhd (\ a . 0)) X 
             = A times (0 -> X) 
             = A 
  \end{code}
  
\end{frame}

\begin{frame}{|catC|-containers}
  Strictly positive functors |catC -> Type|: |catC|-containers

  \begin{itemize}
  \item Shapes |S : Type|
  \item Positions |T : S -> / catC / |
  \end{itemize}

  \begin{code}
  sem(S lhd P) : catC -> Type
  sem(S lhd P) X ddefeq (s : S) times catC(P s, X)


  sem(S lhd P) : (f : catC(X , Y)) -> sem(S lhd P) X -> sem(S lhd P) Y
  sem(S lhd P) f (s , t) ddefeq (s , f circ t)
  \end{code}

  Example:

  \begin{code}
  const A X  = sem(A lhd (\ a . 0)) X 
             = A times catC(0 , X) -- assuming 0 : / catC / initial
             = A
  \end{code}

    
\end{frame}

\begin{frame}{|catC|-container morphisms}
  For any two containers |F = A lhd B|, |G = C lhd D|, container morphisms:

  \begin{code}
                 (f : A -> C) times (g : (a : A) -> D (f a) -> B a)
   white(simeq)  empty
  \end{code}
\end{frame}

\begin{frame}{|catC|-container morphisms -- completeness}
  For any two containers |F = A lhd B|, |G = C lhd D|, container morphisms:

  \begin{code}
          (f : A -> C) times (g : (a : A) -> D (f a) -> B a) 
   simeq  [catC, Type](sem(F), sem(G))
  \end{code}
\end{frame}


\begin{frame}{Strict positivity -- |catC|-containers}
  Data for constructors can be given using |catC|-containers and
  container morphisms:

  \begin{itemize}
  \item Arguments functors are given as |catC-|-containers
  \item |Eqn| functors can be given as containers if we have
    \nconstructors
  \end{itemize}
\end{frame}

\begin{frame}{Coherence problems}
  \begin{itemize}
  \item We can use |catC|-containers to internalise the theory
  \item We still need to be able to talk about the categories of dependent dialgebras
  \item $\hdots$ but this comes with coherence problems
  \end{itemize}
\end{frame}

\begin{frame}{Conclusions}
  \begin{itemize}
  \item |catC|-containers get us far
  \item Defining categories of algebras is problematic
  \end{itemize}

\end{frame}

\end{document}
